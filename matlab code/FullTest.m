%This file is meant to demonstrate many of the useful functions found within tensorlab
%This file is not meant to produce any meaningful results.

%First thing that happens is that I load in JSON representsations of Zeus
%binaries
%Zeus is a powerful trojan
zeus1 = loadjson('../testData/malwarejson/zeus/zeusbin_0a0b988d35e30e88a7f0bb7245febc66.ex0.json');
zeus2 = loadjson('../testData/malwarejson/zeus/zeusbin_0a1aee9e77e0d9a42ef6362fbf61aff2.ex0.json');
%OPCleaver is a set of malware from Iran
cleaver1 = loadjson('/Users/MaxBox1/op-cleaver/0ce968ea8cffb6312f6d17af9044a14f79d6427b9038bcfc6212acb5aa23e74b.json');
testPE1 = PETensor(zeus1.FILE_HEADER);
testPE2 = PETensor(zeus2.FILE_HEADER);

%I then use my function to make these into tensors
test1 = makeTens(zeus1);
test2 = makeTens(zeus2);
testdiff = makeTens(cleaver1);


%Compute CPD

%Here I am computing the Canonical Polyadic Decomposition (CPD)
%This is also called PARAFAC in the Unsupervised Tensor Mining
%This is a generalization of SVD to n rank tensors
%Here I have a 3 rank tensor, so I pass that in as my second input
U = cpd(test1,3);
Uag = cpd(test1,3);

disp('Displaying the cpd of test1');
dispcpd(U);
% disp(isequal(U, Uag)); This is false, but why is it? Isn't one of the
% properties of a CPD that it is unique to the tensor, then how do we get
% two separate 
U2 = cpd(test2,3);
T = cpdgen(U);
T2 = cpdgen(U2);

Udiff = cpd(testdiff,3);
Tdiff = cpdgen(Udiff);
%Find error
Uhat = cpd(noisy(T, 60), 3);
relerr = cpderr(U,Uhat); 
Uhat2 = cpd(noisy(T2, 60), 3);
relerr2 = cpderr(U2,Uhat2); 
%disp(relerr);
%disp(relerr2);
%Visualize
h = figure(1); surf3(T);
set(h,'name','test1 CPD','numbertitle','off')
h = figure(2); surf3(T2);
set(h,'name','test2 CPD','numbertitle','off')
h = figure(3); surf3(test1);
set(h,'name','test1','numbertitle','off')
h = figure(4); surf3(test2);
set(h,'name','test2','numbertitle','off')

function malware_tensor = PETensor(PE)
    malware_tensor = zeros(3,3,3);
    malware_tensor(1,1,1) = PE.NumberOfSections.FileOffset;
    malware_tensor(1,2,1) = PE.NumberOfSections.Value;
    malware_tensor(1,3,1) = PE.NumberOfSections.Offset;
    malware_tensor(2,1,1) = PE.TimeDateStamp.FileOffset;
    %Time is stored in file as a hex value
    %Convert this hex value to decimal
    %Kind of dumb
    hex = strsplit(PE.TimeDateStamp.Value);
    hex = char(hex(1));
    dec = hex2dec(hex(3:end)); %chop of the 0x at the beginning 
    malware_tensor(2,2,1) = dec;
    malware_tensor(2,3,1) = PE.TimeDateStamp.Offset;
    malware_tensor(3,1,1) = PE.PointerToSymbolTable.FileOffset;
    malware_tensor(3,2,1) = PE.PointerToSymbolTable.Value;
    malware_tensor(3,3,1) = PE.PointerToSymbolTable.Offset;

    malware_tensor(1,1,2) = PE.NumberOfSymbols.FileOffset;
    malware_tensor(1,2,2) = PE.NumberOfSymbols.Value;
    malware_tensor(1,3,2) = PE.NumberOfSymbols.Offset;
    malware_tensor(2,1,2) = PE.Machine.FileOffset;
    malware_tensor(2,2,2) = PE.Machine.Value;
    malware_tensor(2,3,2) = PE.Machine.Offset;
    malware_tensor(3,1,2) = PE.Characteristics.FileOffset;
    malware_tensor(3,2,2) = PE.Characteristics.Value;
    malware_tensor(3,3,2) = PE.Characteristics.Offset;
    
    malware_tensor(1,1,3) = PE.SizeOfOptionalHeader.FileOffset;
    malware_tensor(1,2,3) = PE.SizeOfOptionalHeader.FileOffset;
    malware_tensor(1,3,3) = PE.SizeOfOptionalHeader.FileOffset;


    
end
%The basic set up of the tensor is that there multiple matrices
%The first matrix represents the existance of some part of the JSON
%If this exists, then there is another matrix that lists various attributes
%of that JSON object or array
function malware_tensor = makeTens(malware_struct)
    malware_tensor = zeros(3,3,10);
    flags = malware_struct.Flags;
    NT_HEADERS = malware_struct.NT_HEADERS;
    characteristics = malware_struct.FILE_HEADER.Characteristics;
    timeDateStamp = malware_struct.FILE_HEADER.TimeDateStamp;
    machine = malware_struct.FILE_HEADER.Machine;
    PE_0x20_Sections = cell2mat(malware_struct.PE_0x20_Sections);
    directories = malware_struct.Directories;
    
    
    malware_tensor = setflags(malware_tensor, flags);
    malware_tensor = setNT_HEADERS(malware_tensor, NT_HEADERS);
    malware_tensor = setCharacteristics(malware_tensor, characteristics);
    malware_tensor = setTimeDateStamp(malware_tensor, timeDateStamp);
    malware_tensor = setMachine(malware_tensor, machine);
    malware_tensor = setPE(malware_tensor, PE_0x20_Sections);
    malware_tensor = setDirectories(malware_tensor, directories);
   
end

function malware_tensor = setflags(malware_tensor, flags)
    if size(flags)
        malware_tensor(1,1,1) = 1;
    end
    disp flags; 
    if any(strcmp(flags,'IMAGE_FILE_32BIT_MACHINE')) 
        malware_tensor(1,1,2) = 1;
    end
    if any(strcmp(flags,'IMAGE_FILE_EXECUTABLE_IMAGE'))  
        malware_tensor(1,2,2) = 1;
    end
    if any(strcmp(flags,'IMAGE_FILE_LOCAL_SYMS_STRIPPED'))
        malware_tensor(1,3,2) = 1;
    end
    if any(strcmp(flags,'IMAGE_FILE_LINE_NUMS_STRIPPED'))
        malware_tensor(2,1,2) = 1;
    end
end

function malware_tensor = setNT_HEADERS(malware_tensor, NT_HEADERS)
    malware_tensor(1,2,1) = 1;
    if strcmp(NT_HEADERS.Structure, 'IMAGE_NT_HEADERS')
       malware_tensor(1,1,3) = 1; 
    end
    malware_tensor(1,2,3) = NT_HEADERS.Signature.FileOffset;
    malware_tensor(1,3,3) = NT_HEADERS.Signature.Value;
    malware_tensor(2,1,3) = NT_HEADERS.Signature.Offset;
end

function malware_tensor = setCharacteristics(malware_tensor, characteristics)
    malware_tensor(1,3,1) = 1;
    malware_tensor(1,1,4) = characteristics.FileOffset;
    malware_tensor(1,2,4) = characteristics.Value;
    malware_tensor(1,3,4) = characteristics.Offset;
    
    
end

function malware_tensor = setTimeDateStamp(malware_tensor, timeDateStamp)
    malware_tensor(2,1,4) = timeDateStamp.FileOffset;
    hex = strsplit(timeDateStamp.Value);
    hex = char(hex(1));
    dec = hex2dec(hex(3:end)); %chop of the 0x at the beginning 
    
    malware_tensor(2,2,4) = dec;
    malware_tensor(2,3,4) = timeDateStamp.Offset;
end

function malware_tensor = setMachine(malware_tensor, machine)
    malware_tensor(3,1,4) = machine.FileOffset;
    malware_tensor(3,2,4) = machine.Value;
    malware_tensor(3,3,4) = machine.Offset;

end

function malware_tensor = setPE(malware_tensor, PE_0x20_Sections)
    malware_tensor(2,1,1) = 1;
    for i = 1:3
       malware_tensor(i,1,5) = hex2dec(PE_0x20_Sections(i).MD5);
       malware_tensor(i,2,5) = PE_0x20_Sections(i).Entropy;
       malware_tensor(i,3,5) = sum(double(PE_0x20_Sections(i).Name.Value));
    end
    
end

function malware_tensor = setDirectories(malware_tensor, directories)
    for i = 1:5
        directory = cell2mat(directories(i));
        malware_tensor(ceil((i+4)/3),mod((3 + i), 3) + 1,1) = 1;
        malware_tensor(1,1,5 + i) =  directory.VirtualAddress.FileOffset;
        malware_tensor(1,2,5 + i) =  directory.VirtualAddress.Value;
        malware_tensor(1,3,5 + i) =  directory.VirtualAddress.Offset;
        malware_tensor = directoryStructureVal(directory.Structure, malware_tensor, 5+i);
        malware_tensor(3,1,5 + i) =  directory.Size.FileOffset;
        malware_tensor(3,2,5 + i) =  directory.Size.Value;
        malware_tensor(3,3,5 + i) =  directory.Size.Offset;
        
    end
    
end

function malware_tensor = directoryStructureVal(structure, malware_tensor, i)
    if strcmp(structure, 'IMAGE_DIRECTORY_ENTRY_EXPORT')
        malware_tensor(2,1,i) = 1;
    end
    if strcmp(structure, 'IMAGE_DIRECTORY_ENTRY_IMPORT')
        malware_tensor(2,2,i) = 1;
    end
    if strcmp(structure, 'IMAGE_DIRECTORY_ENTRY_RESOURCE')
        malware_tensor(2,3,i) = 1;
    end
    if strcmp(structure, 'IMAGE_DIRECTORY_ENTRY_EXCEPTION')
        malware_tensor(2,1,i) = 2;
    end
end

function nothing = dispcpd(cpd)
    celldisp(cpd(1));
    celldisp(cpd(2));
    celldisp(cpd(3));
end


%Some notes when this was presented to the Malware Research Lab

%Theano look into
%Does this exploit GPU
%I am fairly confident that this does not exploit the GPU,
%There is a special class of arrays that matlab uses for GPU based
%programs. Tensorlab does not seem to support that.
%Each of these tensors is 3x3x10
%How do you normalize it?
%Generally want the scales to be in all the same range.
%This means we have one "face" matrix and each cell in that matrix gets
%a separate matrix just for itself (3x3 = 9 cells means 9 matrices + 1 matrix for
%the face = 10).

%This tensor is structured like this
%flags, NT_Headers, FILE_HEADER (characeristics, timedatestamp,machine),
%PE_0X20,directory, directory
%directory, directory, directory